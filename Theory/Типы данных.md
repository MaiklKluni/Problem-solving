# Тип данных

### Основные типы данных:

<table>
  <tr>
    <th>Название</th>
    <th>Английский</th>
    <th>Пример</th>
    <th>Объяснение</th>
    <th>Функция в коде</th>
  </tr>
  <tr>
    <td>Целые числа</td>
    <td>Integers</td>
    <td>age = 25</td>
    <td>Целые числа представляются без десятичной точки. Они могут быть положительными или отрицательными.</td>
    <td>int()</td>
  </tr>
  <tr>
    <td>Числа с плавающей точкой</td>
    <td>Floating-point numbers</td>
    <td>pi = 3.14159</td>
    <td>Числа с плавающей точкой представляют дробные значения. Они записываются с десятичной точкой.</td>
    <td>float()</td>
  </tr>
  <tr>
    <td>Строки</td>
    <td>Strings</td>
    <td>name = "Alice"</td>
    <td>Строки представляют текстовые данные. Они заключаются в одинарные или двойные кавычки.</td>
    <td>str()</td>
  </tr>
  <tr>
    <td>Списки</td>
    <td>Lists</td>
    <td>fruits = ["apple", "banana", "cherry"]</td>
    <td>Списки - упорядоченные коллекции элементов. Каждый элемент имеет свой индекс, начиная с 0.</td>
    <td>list()</td>
  </tr>
  <tr>
    <td>Кортежи</td>
    <td>Tuples</td>
    <td>point = (3, 7)</td>
    <td>Кортежи - упорядоченные и неизменяемые коллекции элементов. Они похожи на списки, но не могут быть изменены после создания.</td>
    <td>tuple()</td>
  </tr>
  <tr>
    <td>Словари</td>
    <td>Dictionaries</td>
    <td>person = {"name": "John", "age": 30}</td>
    <td>Словари хранят пары "ключ-значение". Ключи уникальны, их можно использовать для доступа к значениям.</td>
    <td>dict()</td>
  </tr>
  <tr>
    <td>Булевы значения</td>
    <td>Booleans</td>
    <td>is_active = True</td>
    <td>Булевы значения представляют истинность или ложность. Используются для логических операций и контроля выполнения кода.</td>
    <td>bool()</td>
  </tr>
  <tr>
    <td>Множества</td>
    <td>Sets</td>
    <td>colors = {"red", "green", "blue"}</td>
    <td>Множества содержат уникальные элементы и используются для операций над множествами, такими как объединение, пересечение и разность.</td>
    <td>set()</td>
  </tr>
  <tr>
    <td>Неизменяемые множества</td>
    <td>Frozensets</td>
    <td>immutable_colors = frozenset(["red", "green", "blue"])</td>
    <td>Frozensets - это неизменяемые множества, которые можно использовать в качестве ключей в словарях.</td>
    <td>frozenset()</td>
  </tr>
  <tr>
    <td>Диапазоны</td>
    <td>Ranges</td>
    <td>numbers = range(1, 6)</td>
    <td>Диапазоны представляют последовательности чисел. Они используются для итерации через цикл for и не хранят все значения в памяти.</td>
    <td>range()</td>
  </tr>
  <tr>
    <td>Байтовые строки</td>
    <td>Bytes</td>
    <td>data = b"hello"</td>
    <td>Байтовые строки содержат байты (целые числа от 0 до 255) и используются для работы с бинарными данными.</td>
    <td>bytes()</td>
  </tr>
  <tr>
    <td>Массивы байтов</td>
    <td>Bytearrays</td>
    <td>byte_data = bytearray(b"hello")</td>
    <td>Массивы байтов аналогичны байтовым строкам, но являются изменяемыми. Они широко используются для работы с бинарными данными.</td>
    <td>bytearray()</td>
  </tr>
  <tr>
    <td>Комплексные числа</td>
    <td>Complex numbers</td>
    <td>c = 3 + 2j</td>
    <td>Комплексные числа имеют вещественную и мнимую части. Они используются в математических вычислениях, например, в алгоритмах сигнальной обработки.</td>
    <td>complex()</td>
  </tr>
  <tr>
    <td>Значение отсутствия</td>
    <td>None</td>
    <td>result = None</td>
    <td>Тип данных None представляет отсутствие значения. Он используется для обозначения, что переменная не содержит данных или ее значение не определено.</td>
    <td>None</td>
  </tr>
</table>


## Объекты в Python
Всё в Python является объектами.

Для проверки принадлежности объекта к определенному классу или типу данных в Python, используется метод: 

> isinstance(object, classinfo)

Он принимает два аргумента: *object*, который нужно проверить, и *classinfo* (класс или тип данных), к которому нужно проверить принадлежность.  

Example:

    isinstance(1, object)
    >>> True
    isinstance(list(), object)
    >>> True
    isinstance(True, object)
    >>> True
    def foo():
    ...    pass
    ...
    isinstance(foo, object)
    >>> True

Этот код демонстрирует, что всё в Python — на самом деле объекты. Каждый объект содержит как минимум три вида данных:

- Счётчик ссылок.
- Тип.
- Значение.

[*Счётчик ссылок*](https://docs.python.org/3/library/sys.html#sys.getrefcount) используется для управления памятью. Подробно об этом управлении написано в [Memory Management in Python](https://realpython.com/python-memory-management/).  
*Тип* — используется на уровне CPython для обеспечения типобезопасности в ходе исполнения (runtime).  
*Значение* — это фактическое значение, ассоциированное с объектом.

## Изменяемые и неизменяемые объекты

В Python есть два типа объектов:

Неизменяемые объекты (не могут быть изменены);
Изменяемые объекты (могут быть изменены).

Характеристика неизменяемости некоторых популярных типов:
<table>
  <tr>
    <th>Тип</th>
    <th>Неизменяемый?</th>
  </tr>
  <tr>
    <td>int</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>float</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>bool</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>complex</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>tuple</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>frozenset</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>str</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>list</td>
    <td>Нет</td>
  </tr>
  <tr>
    <td>set</td>
    <td>Нет</td>
  </tr>
  <tr>
    <td>dict</td>
    <td>Нет</td>
  </tr>
</table>

Для примера воспользуемся командами:

> id() возвращает адрес памяти объекта;  
> is возвращает True, если и только если два объекта имеют одинаковый адрес памяти.

Присвоим переменной x значение 5 и узнаем адрес памяти объекта.

    x = 5  
    id(x)
    >>> 94529957049376

 Попробуем изменить значение x с помощью сложения, и получим новый объект:

    x += 1
    x
    >>> 6
    id(x)
    >>> 94529957049408

Хотя может показаться, что этот код просто меняет значение x, но на самом деле получаем новый объект.

Тип str тоже неизменяем:

    s = "real_python"
    id(s) 
    >>> 140637819584048
    s += "_rocks"
    s
    >>> 'real_python_rocks'
    id(s)
    >>> 140637819609424

И в этом случае s после операции += получает другой адрес памяти.

---

Бонус: Оператор += преобразовывается в различные вызовы методов.  
Для некоторых объектов, таких как список, += преобразует в __iadd__() (локальное добавление). Оно изменит себя и вернёт тот же ID. Однако у str и int нет этих методов, и в результате будет вызываться __add__() вместо __iadd__().  
Подробнее об этом рассказывается в документации по [моделям данных Python](https://docs.python.org/3/reference/datamodel.html#object.__iadd__).

---

При попытке напрямую изменить строковое значение s мы получим ошибку:

    s[0] = "R"

Обратная трассировка (последними отображаются самые свежие вызовы):

    File "<stdin>", line 1, in <mоdule>
    TypeError: 'str' object does not support item assignment

Приведённый выше код сбоит и Python сообщает, что str не поддерживает это изменение, что соответствует определению неизменяемости типа str.

Сравните с изменяемым объектом, например, со списком:

    my_list = [1, 2, 3]
    id(my_list)
    >>> 140637819575368
    my_list.append(4)
    my_list
    >>> [1, 2, 3, 4]
    id(my_list)
    >>> 140637819575368

Этот код демонстрирует основное различие между двумя типами объектов. Изначально у my_list есть ID. Даже после добавления к списку 4, my_list всё ещё имеет тот же ID. Причина в том, что тип list является изменяемым.

Вот ещё одна демонстрация изменяемости списка с помощью присваивания:

    my_list[0] = 0
    my_list
    >>> [0, 2, 3, 4]
    id(my_list)
    >>> 140637819575368

В этом коде мы изменили my_list и задали ему в качестве первого элемента 0. Однако список сохранил тот же ID после этой операции.

Используемые материалы:  
[https://habr.com/ru/companies/vk/articles/454324/]  
[https://habr.com/ru/sandbox/246396/]
