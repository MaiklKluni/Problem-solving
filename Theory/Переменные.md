# Переменные
### Коротко о главном
Python использует систему ссылок для работы с переменными:

- Переменная - это имя, ссылающееся на объект в памяти
- Один объект может иметь несколько имён
- Присваивание создаёт новую ссылку, а не копию объекта
- Сборщик мусора удаляет объекты, на которые нет ссылок

Синтаксис создания переменных в Python прост и интуитивно понятен:  

> имя_переменной = значение  

Example:  

    age = 25                   # Возраст  
    name = "Maikl"             # Имя  
    temperature = 36.6         # Температура  
    is_raining = False         # Идёт ли дождь  

Python автоматически определяет тип переменной на основе присвоенного значения. Это называется **динамической типизацией**.

Теперь по подробнее...

## Объекты в Python
Всё в Python является объектами.

Для проверки принадлежности объекта к определенному классу или типу данных в Python, используется метод: 

> isinstance(object, classinfo)

Он принимает два аргумента: *object*, который нужно проверить, и *classinfo* (класс или тип данных), к которому нужно проверить принадлежность.  

Example:

    isinstance(1, object)
    >>> True
    isinstance(list(), object)
    >>> True
    isinstance(True, object)
    >>> True
    def foo():
    ...    pass
    ...
    isinstance(foo, object)
    >>> True

Этот код демонстрирует, что всё в Python — на самом деле объекты. Каждый объект содержит как минимум три вида данных:

- Счётчик ссылок.
- Тип.
- Значение.

[*Счётчик ссылок*](https://docs.python.org/3/library/sys.html#sys.getrefcount) используется для управления памятью. Подробно об этом управлении написано в [Memory Management in Python](https://realpython.com/python-memory-management/).  
*Тип* — используется на уровне CPython для обеспечения типобезопасности в ходе исполнения (runtime).  
*Значение* — это фактическое значение, ассоциированное с объектом.

## Изменяемые и неизменяемые объекты

В Python есть два типа объектов:

Неизменяемые объекты (не могут быть изменены);
Изменяемые объекты (могут быть изменены).

Характеристика неизменяемости некоторых популярных типов:
<table>
  <tr>
    <th>Тип</th>
    <th>Неизменяемый?</th>
  </tr>
  <tr>
    <td>int</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>float</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>bool</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>complex</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>tuple</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>frozenset</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>str</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>list</td>
    <td>Нет</td>
  </tr>
  <tr>
    <td>set</td>
    <td>Нет</td>
  </tr>
  <tr>
    <td>dict</td>
    <td>Нет</td>
  </tr>
</table>

Для примера воспользуемся командами:

> id() возвращает адрес памяти объекта;  
> is возвращает True, если и только если два объекта имеют одинаковый адрес памяти.

Присвоим переменной x значение 5 и узнаем адрес памяти объекта.

    x = 5  
    id(x)
    >>> 94529957049376

 Попробуем изменить значение x с помощью сложения, и получим новый объект:

    x += 1
    x
    >>> 6
    id(x)
    >>> 94529957049408

Хотя может показаться, что этот код просто меняет значение x, но на самом деле получаем новый объект.

Тип str тоже неизменяем:

    s = "real_python"
    id(s) 
    >>> 140637819584048
    s += "_rocks"
    s
    >>> 'real_python_rocks'
    id(s)
    >>> 140637819609424

И в этом случае s после операции += получает другой адрес памяти.

---

Бонус: Оператор += преобразовывается в различные вызовы методов.  
Для некоторых объектов, таких как список, += преобразует в __iadd__() (локальное добавление). Оно изменит себя и вернёт тот же ID. Однако у str и int нет этих методов, и в результате будет вызываться __add__() вместо __iadd__().  
Подробнее об этом рассказывается в документации по [моделям данных Python](https://docs.python.org/3/reference/datamodel.html#object.__iadd__).

---

При попытке напрямую изменить строковое значение s мы получим ошибку:

    s[0] = "R"

Обратная трассировка (последними отображаются самые свежие вызовы):

    File "<stdin>", line 1, in <mоdule>
    TypeError: 'str' object does not support item assignment

Приведённый выше код сбоит и Python сообщает, что str не поддерживает это изменение, что соответствует определению неизменяемости типа str.

Сравните с изменяемым объектом, например, со списком:

    my_list = [1, 2, 3]
    id(my_list)
    >>> 140637819575368
    my_list.append(4)
    my_list
    >>> [1, 2, 3, 4]
    id(my_list)
    >>> 140637819575368

Этот код демонстрирует основное различие между двумя типами объектов. Изначально у my_list есть ID. Даже после добавления к списку 4, my_list всё ещё имеет тот же ID. Причина в том, что тип list является изменяемым.

Вот ещё одна демонстрация изменяемости списка с помощью присваивания:

    my_list[0] = 0
    my_list
    >>> [0, 2, 3, 4]
    id(my_list)
    >>> 140637819575368

В этом коде мы изменили my_list и задали ему в качестве первого элемента 0. Однако список сохранил тот же ID после этой операции.

Используемые материалы:
[https://habr.com/ru/companies/vk/articles/454324/]
[https://habr.com/ru/sandbox/246396/]
